{"version":3,"sources":["../../src/mini-adapter/XMLHttpRequest.ts"],"names":["EventTarget","_requestHeader","Map","_responseHeader","_requestTask","contentTypes","json","text","arraybuffer","_triggerEvent","type","event","target","call","_changeReadyState","readyState","$XMLHttpRequest","onabort","onerror","onload","onloadstart","onprogress","ontimeout","onloadend","onreadystatechange","response","responseText","_responseType","responseXML","status","statusText","upload","withCredentials","set","myRequestTask","get","abort","responseHeader","Object","keys","map","header","join","method","url","flag","_method","_url","$data","value","myHeader","listener","UNSEND","OPENED","HEADERS_RECEIVED","LOADING","DONE"],"mappings":"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","sourcesContent":["// @ts-nocheck\n// tslint:disable\nimport EventTarget from './EventTarget';\n\ndeclare let my: any;\nconst _requestHeader = new Map();\nconst _responseHeader = new Map();\nconst _requestTask = new Map();\nconst contentTypes = {\n  json: 'application/json',\n  text: 'application/text',\n  arraybuffer: 'application/octet-stream',\n};\n\nfunction _triggerEvent(type, event = { target: this }) {\n  if (typeof this[`on${type}`] === 'function') {\n    this[`on${type}`].call(this, event);\n  }\n}\n\nfunction _changeReadyState(readyState, event = { readyState }) {\n  this.readyState = readyState;\n  _triggerEvent.call(this, 'readystatechange', event);\n}\n\nexport class $XMLHttpRequest extends EventTarget {\n  public static UNSEND: number;\n  public static OPENED: number;\n  public static HEADERS_RECEIVED: number;\n  public static LOADING: number;\n  public static DONE: number;\n  public onabort: any;\n  public onerror: any;\n  public onload: any;\n  public onloadstart: any;\n  public onprogress: any;\n  public ontimeout: any;\n  public onloadend: any;\n  public onreadystatechange: any;\n  public readyState: number;\n  public response: any;\n  public responseText: any;\n  public _responseType: string;\n  public responseXML: any;\n  public status: number;\n  public statusText: string;\n  public upload: any;\n  public withCredentials: boolean;\n  public timeout: number;\n\n  public _url: string;\n  public _method: string;\n\n  constructor() {\n    super();\n\n    this.onabort = null;\n    this.onerror = null;\n    this.onload = null;\n    this.onloadstart = null;\n    this.onprogress = null;\n    this.ontimeout = null;\n    this.onloadend = null;\n\n    this.onreadystatechange = null;\n    this.readyState = 0;\n    this.response = null;\n    this.responseText = null;\n    this._responseType = 'text';\n    this.responseXML = null;\n    this.status = 0;\n    this.statusText = '';\n    this.upload = {};\n    this.withCredentials = false;\n\n    _requestHeader.set('requestHeader', {\n      'content-type': 'application/x-www-form-urlencoded',\n    });\n  }\n\n  set responseType(type: string) {\n    this._responseType = type;\n  }\n\n  public abort() {\n    const myRequestTask = _requestTask.get('requestTask');\n\n    if (myRequestTask) {\n      myRequestTask.abort();\n    }\n  }\n\n  public getAllResponseHeaders() {\n    const responseHeader = _responseHeader.get('responseHeader');\n\n    return Object.keys(responseHeader)\n      .map((header) => {\n        return `${header}: ${responseHeader[header]}`;\n      })\n      .join('\\n');\n  }\n\n  public getResponseHeader(header) {\n    return _responseHeader.get('responseHeader')[header];\n  }\n\n  public open(method, url /* GET/POST*/, flag) {\n    this._method = method;\n    this._url = url;\n    // _changeReadyState.call(this, XMLHttpRequest.OPENED);\n  }\n\n  public overrideMimeType() {}\n\n  public send($data = '') {\n    // if (this.readyState !== XMLHttpRequest.OPENED) {\n    //   throw new Error(\n    //     \"Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.\",\n    //   );\n    // } else {\n    //   const url = this._url;\n    //   const header = _requestHeader.get('requestHeader');\n    //   const responseType = this._responseType;\n\n    //   if (contentTypes[responseType]) {\n    //     header['content-type'] = contentTypes[responseType];\n    //   }\n\n    //   delete this.response;\n    //   this.response = null;\n\n    //   const onSuccess = ({ data, status, headers }) => {\n    //     // status = status === undefined ? 200 : status;\n\n    //     // try {\n    //     //   if (\n    //     //     data == null ||\n    //     //     (data instanceof ArrayBuffer && data.byteLength == 0)\n    //     //   ) {\n    //     //     status = 404;\n    //     //   }\n    //     // } catch (e) {}\n\n    //     // this.status = status;\n    //     // if (headers) {\n    //     //   _responseHeader.set('responseHeader', headers);\n    //     // }\n    //     // _triggerEvent.call(this, 'loadstart');\n    //     // // _changeReadyState.call(this, XMLHttpRequest.HEADERS_RECEIVED);\n    //     // // _changeReadyState.call(this, XMLHttpRequest.LOADING);\n\n    //     // this.response = data;\n\n    //     // if (data instanceof ArrayBuffer) {\n    //     //   // TODO temporary solution, fix native gc error.\n    //     //   this.response = data.slice(0);\n    //     //   Object.defineProperty(this, 'responseText', {\n    //     //     enumerable: true,\n    //     //     configurable: true,\n    //     //     get() {\n    //     //       throw new Error(\n    //     //         'InvalidStateError : responseType is ' + this._responseType,\n    //     //       );\n    //     //     },\n    //     //   });\n    //     // } else {\n    //     //   this.responseText = data;\n    //     // }\n    //     // _changeReadyState.call(this, XMLHttpRequest.DONE);\n    //     // _triggerEvent.call(this, 'load');\n    //     // _triggerEvent.call(this, 'loadend');\n    //   };\n\n    //   const onFail = (e) => {\n    //     const errMsg = e.message || e.errorMessage;\n    //     // TODO 规范错误\n    //     if (!errMsg) {\n    //       return;\n    //     }\n    //     if (errMsg.indexOf('abort') !== -1) {\n    //       _triggerEvent.call(this, 'abort', {\n    //         message: errMsg + this._url,\n    //       });\n    //     } else {\n    //       _triggerEvent.call(this, 'error', {\n    //         message: errMsg + this._url,\n    //       });\n    //     }\n    //     _triggerEvent.call(this, 'loadend');\n    //   };\n\n    //   const requestTask = my.request({\n    //     $data,\n    //     url,\n    //     method: this._method,\n    //     timeout: this.timeout ? this.timeout : 30000,\n    //     headers: header,\n    //     dataType: responseType,\n    //     success: onSuccess,\n    //     fail: onFail,\n    //   });\n    //   _requestTask.set('requestTask', requestTask);\n    // }\n  }\n\n  public setRequestHeader(header, value) {\n    const myHeader = _requestHeader.get('requestHeader');\n\n    myHeader[header] = value;\n    _requestHeader.set('requestHeader', myHeader);\n  }\n\n  public addEventListener(type, listener) {\n    if (typeof listener !== 'function') {\n      return;\n    }\n\n    this['on' + type] = (event: any = {}) => {\n      event.target = event.target || this;\n      listener.call(this, event);\n    };\n  }\n\n  public removeEventListener(type, listener) {\n    if (this['on' + type] === listener) {\n      this['on' + type] = null;\n    }\n  }\n}\n\n// TODO 没法模拟 HEADERS_RECEIVED 和 LOADING 两个状态\n$XMLHttpRequest.UNSEND = 0;\n$XMLHttpRequest.OPENED = 1;\n$XMLHttpRequest.HEADERS_RECEIVED = 2;\n$XMLHttpRequest.LOADING = 3;\n$XMLHttpRequest.DONE = 4;\n"],"file":"XMLHttpRequest.js"}