import _defineProperty from "@babel/runtime/helpers/defineProperty";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _isNil from "lodash/isNil";

var _dec, _class;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { injectable } from 'inversify';
import 'reflect-metadata';
var blur = "varying vec2 v_UV;\n\nuniform float u_BloomFinal: 0.0;\nuniform sampler2D u_Texture;\nuniform sampler2D u_Texture2;\n\nuniform vec2 u_ViewportSize: [1.0, 1.0];\nuniform float u_radius: 5.0;\nuniform float u_intensity: 0.3;\nuniform float u_baseRadio: 0.5;\n\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n\nfloat luminance(vec4 color) {\n  return  0.2125 * color.r + 0.7154 * color.g + 0.0721 * color.b;\n}\n\nvoid main() {\n  // vec4 baseColor = texture2D(u_Texture, v_UV);\n  // float lum = luminance(baseColor);\n  // baseColor.a *= lum;\n\n  // gl_FragColor = baseColor;\n\n  // if(u_BloomFinal > 0.0) { // \n  //   gl_FragColor = baseColor; //-- \n  // }\n\n  float r = sqrt(u_radius);\n\n  vec4 c1 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(u_radius, 0.0));\n  // c1 *= luminance(c1);\n  vec4 c2 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(0.0, u_radius));\n  // c2 *= luminance(c2);\n  vec4 c3 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(r, r));\n  // c3 *= luminance(c3);\n  vec4 c4 = blur9(u_Texture, v_UV, u_ViewportSize, vec2(r, -r));\n  // c4 *= luminance(c4);\n  vec4 inbloomColor = (c1 + c2 + c3 + c4) * 0.25;\n\n  // float lum = luminance(inbloomColor);\n  // inbloomColor.rgb *= lum;\n\n  if(u_BloomFinal > 0.0) {\n    vec4 baseColor = texture2D(u_Texture2, v_UV);\n    float baselum = luminance(baseColor);\n    // float lum = luminance(inbloomColor);\n    // vec4 bloom = vec4(lum);\n    // inbloomColor.a *= lum;\n    // gl_FragColor = inbloomColor * u_intensity + texture2D(u_Texture2, v_UV);\n    // gl_FragColor = inbloomColor * 0.5 + texture2D(u_Texture2, v_UV);\n    // gl_FragColor = baseColor;\n    // gl_FragColor = inbloomColor;\n    // vec4 mixColor = mix(baseColor, inbloomColor, max(u_intensity - 0.3, 0.0));\n    // mixColor.a = max(baseColor.a, mixColor.a);\n    gl_FragColor = mix(inbloomColor, baseColor, max(1.0 - u_intensity, u_baseRadio));\n    // gl_FragColor = mixColor;\n    // gl_FragColor = baseColor;\n    \n    if(baselum <= 0.0) {\n      // float lum = luminance(inbloomColor);\n      // inbloomColor.rgb *= lum;\n      gl_FragColor += inbloomColor * u_intensity;\n    }\n    // gl_FragColor = inbloomColor * baseColor + baseColor;\n    // gl_FragColor = baseColor + bloom * 0.5;\n  } else {\n    gl_FragColor = inbloomColor;\n  }\n  // gl_FragColor = inbloomColor;\n\n  // float h = 0.01;\n  \n  // vec4 color11 = texture2D( u_Texture, vec2( v_UV.x - 1.0 * h, v_UV.y + 1.0 * h) );\n  // vec4 color12 = texture2D( u_Texture, vec2( v_UV.x - 0.0 * h, v_UV.y + 1.0 * h) );\n  // vec4 color13 = texture2D( u_Texture, vec2( v_UV.x + 1.0 * h, v_UV.y + 1.0 * h) );\n\n  // vec4 color21 = texture2D( u_Texture, vec2( v_UV.x - 1.0 * h, v_UV.y) );\n  // vec4 color23 = texture2D( u_Texture, vec2( v_UV.x + 1.0 * h, v_UV.y) );\n\n  // vec4 color31 = texture2D( u_Texture, vec2( v_UV.x - 1.0 * h, v_UV.y-1.0*h) );\n  // vec4 color32 = texture2D( u_Texture, vec2( v_UV.x - 0.0 * h, v_UV.y-1.0*h) );\n  // vec4 color33 = texture2D( u_Texture, vec2( v_UV.x + 1.0 * h, v_UV.y-1.0*h) );\n\n  // vec4 bloomColor =\n  //   color11 + \n  //   color12 + \n  //   color13 + \n  //   color21 + \n  //   color21 + \n  //   color23 + \n  //   color31 + \n  //   color32 + \n  //   color33;\n\n  //   if(baseColor.a > 0.0) {\n      \n  //     gl_FragColor.r = min(bloomColor.r, baseColor.r);\n  //     gl_FragColor.g = min(bloomColor.g, baseColor.g);\n  //     gl_FragColor.b = min(bloomColor.b, baseColor.b);\n  //     gl_FragColor.a = min(bloomColor.a, baseColor.a);\n\n  //     gl_FragColor = mix(inbloomColor, gl_FragColor, 0.7);\n  //   } else {\n  //     gl_FragColor = bloomColor/9.0;\n  //   } \n}";
var quad = "attribute vec2 a_Position;\n\nvarying vec2 v_UV;\n\nvoid main() {\n  v_UV = 0.5 * (a_Position + 1.0);\n  gl_Position = vec4(a_Position, 0., 1.);\n}";
import BasePostProcessingPass from '../BasePostProcessingPass';
var BloomPass = (_dec = injectable(), _dec(_class = function (_BasePostProcessingPa) {
  _inherits(BloomPass, _BasePostProcessingPa);

  var _super = _createSuper(BloomPass);

  function BloomPass() {
    _classCallCheck(this, BloomPass);

    return _super.apply(this, arguments);
  }

  _createClass(BloomPass, [{
    key: "setupShaders",
    value: function setupShaders() {
      this.shaderModuleService.registerModule('blur-pass', {
        vs: quad,
        fs: blur
      });

      var _this$shaderModuleSer = this.shaderModuleService.getModule('blur-pass'),
          vs = _this$shaderModuleSer.vs,
          fs = _this$shaderModuleSer.fs,
          uniforms = _this$shaderModuleSer.uniforms;

      var _this$rendererService = this.rendererService.getViewportSize(),
          width = _this$rendererService.width,
          height = _this$rendererService.height;

      return {
        vs: vs,
        fs: fs,
        uniforms: _objectSpread(_objectSpread({}, uniforms), {}, {
          u_ViewportSize: [width, height]
        })
      };
    }
  }, {
    key: "convertOptionsToUniforms",
    value: function convertOptionsToUniforms(options) {
      var uniforms = {};

      if (!_isNil(options.bloomRadius)) {
        uniforms.u_radius = options.bloomRadius;
      }

      if (!_isNil(options.bloomIntensity)) {
        uniforms.u_intensity = options.bloomIntensity;
      }

      if (!_isNil(options.bloomBaseRadio)) {
        uniforms.u_baseRadio = options.bloomBaseRadio;
      }

      return uniforms;
    }
  }]);

  return BloomPass;
}(BasePostProcessingPass)) || _class);
export { BloomPass as default };
//# sourceMappingURL=BloomPass.js.map