"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GlobelPointFillTriangulation = GlobelPointFillTriangulation;
exports.HeatmapGridTriangulation = HeatmapGridTriangulation;
exports.HeatmapTriangulation = HeatmapTriangulation;
exports.LineArcTriangulation = LineArcTriangulation;
exports.LineTriangulation = LineTriangulation;
exports.PointExtrudeTriangulation = PointExtrudeTriangulation;
exports.PointFillTriangulation = PointFillTriangulation;
exports.PointImageTriangulation = PointImageTriangulation;
exports.PolygonExtrudeTriangulation = PolygonExtrudeTriangulation;
exports.RasterImageTriangulation = RasterImageTriangulation;
exports.SimpleLineTriangulation = SimpleLineTriangulation;
exports.earthOuterTriangulation = earthOuterTriangulation;
exports.earthTriangulation = earthTriangulation;
exports.polygonTriangulation = polygonTriangulation;
exports.polygonTriangulationWithCenter = polygonTriangulationWithCenter;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _l7Utils = require("@antv/l7-utils");

var _earcut = _interopRequireDefault(require("earcut"));

var _glMatrix = require("gl-matrix");

var _utils = require("../earth/utils");

var _extrude_polyline = _interopRequireDefault(require("../utils/extrude_polyline"));

var _geo = require("../utils/geo");

var _extrude = _interopRequireWildcard(require("./shape/extrude"));

var _Path = require("./shape/Path");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var GeometryCache = {};

function PointFillTriangulation(feature) {
  var coordinates = (0, _geo.calculateCentroid)(feature.coordinates);
  return {
    vertices: [].concat((0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(coordinates)),
    indices: [0, 1, 2, 2, 3, 0],
    size: coordinates.length
  };
}

function GlobelPointFillTriangulation(feature) {
  var coordinates = (0, _geo.calculateCentroid)(feature.coordinates);
  var xyz = (0, _utils.lglt2xyz)(coordinates);
  return {
    vertices: [].concat((0, _toConsumableArray2.default)(xyz), (0, _toConsumableArray2.default)(xyz), (0, _toConsumableArray2.default)(xyz), (0, _toConsumableArray2.default)(xyz)),
    indices: [0, 1, 2, 2, 3, 0],
    size: xyz.length
  };
}

function PointExtrudeTriangulation(feature) {
  var shape = feature.shape;

  var _getGeometry = getGeometry(shape, false),
      positions = _getGeometry.positions,
      index = _getGeometry.index,
      normals = _getGeometry.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}

function PointImageTriangulation(feature) {
  var coordinates = (0, _geo.calculateCentroid)(feature.coordinates);
  return {
    vertices: (0, _toConsumableArray2.default)(coordinates),
    indices: [0],
    size: coordinates.length
  };
}

function LineTriangulation(feature) {
  var coordinates = feature.coordinates,
      originCoordinates = feature.originCoordinates,
      version = feature.version;
  var line = new _extrude_polyline.default({
    dash: true,
    join: 'bevel'
  });

  if (version === 'GAODE2.x') {
    var path1 = coordinates;

    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }

    var path2 = originCoordinates;

    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }

    for (var i = 0; i < path1.length; i++) {
      var item1 = path1[i];
      var item2 = path2[i];
      line.extrude_gaode2(item1, item2);
    }
  } else {
    var path = coordinates;

    if (!Array.isArray(path[0][0])) {
      path = [coordinates];
    }

    path.forEach(function (item) {
      line.extrude(item);
    });
  }

  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    size: 6
  };
}

function SimpleLineTriangulation(feature) {
  var coordinates = feature.coordinates,
      originCoordinates = feature.originCoordinates,
      version = feature.version;
  var line = new _extrude_polyline.default({
    dash: true,
    join: 'bevel'
  });

  if (version === 'GAODE2.x') {
    var path1 = coordinates;

    if (!Array.isArray(path1[0][0])) {
      path1 = [coordinates];
    }

    var path2 = originCoordinates;

    if (!Array.isArray(path2[0][0])) {
      path2 = [originCoordinates];
    }

    for (var i = 0; i < path1.length; i++) {
      var item1 = path1[i];
      var item2 = path2[i];
      line.simpleExtrude_gaode2(item1, item2);
    }
  } else {
    var path = coordinates;

    if (!Array.isArray(path[0][0])) {
      path = [coordinates];
    }

    path.forEach(function (item) {
      line.simpleExtrude(item);
    });
  }

  var linebuffer = line.complex;
  return {
    vertices: linebuffer.positions,
    indices: linebuffer.indices,
    normals: linebuffer.normals,
    size: 6
  };
}

function polygonTriangulation(feature) {
  var coordinates = feature.coordinates;

  var flattengeo = _earcut.default.flatten(coordinates);

  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: (0, _earcut.default)(vertices, holes, dimensions),
    vertices: vertices,
    size: dimensions
  };
}

function polygonTriangulationWithCenter(feature) {
  var coordinates = feature.coordinates;

  var flattengeo = _earcut.default.flatten(coordinates);

  var vertices = flattengeo.vertices,
      dimensions = flattengeo.dimensions,
      holes = flattengeo.holes;
  return {
    indices: (0, _earcut.default)(vertices, holes, dimensions),
    vertices: getVerticesWithCenter(vertices),
    size: dimensions + 4
  };
}

function getVerticesWithCenter(vertices) {
  var verticesWithCenter = [];

  var _calculatePointsCente = (0, _geo.calculatePointsCenterAndRadius)(vertices),
      center = _calculatePointsCente.center,
      radius = _calculatePointsCente.radius;

  for (var i = 0; i < vertices.length; i += 2) {
    var lng = vertices[i];
    var lat = vertices[i + 1];
    verticesWithCenter.push.apply(verticesWithCenter, [lng, lat, 0].concat((0, _toConsumableArray2.default)(center), [radius]));
  }

  return verticesWithCenter;
}

function PolygonExtrudeTriangulation(feature) {
  var coordinates = feature.coordinates;

  var _extrude_PolygonNorma = (0, _extrude.extrude_PolygonNormal)(coordinates, true),
      positions = _extrude_PolygonNorma.positions,
      index = _extrude_PolygonNorma.index,
      normals = _extrude_PolygonNorma.normals;

  return {
    vertices: positions,
    indices: index,
    normals: normals,
    size: 5
  };
}

function HeatmapGridTriangulation(feature) {
  var shape = feature.shape;

  var _getHeatmapGeometry = getHeatmapGeometry(shape),
      positions = _getHeatmapGeometry.positions,
      index = _getHeatmapGeometry.index;

  return {
    vertices: positions,
    indices: index,
    size: 3
  };
}

function RasterImageTriangulation(feature) {
  var coordinates = feature.coordinates;
  var positions = [].concat((0, _toConsumableArray2.default)(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], (0, _toConsumableArray2.default)(coordinates[1]), [0, 1, 0], (0, _toConsumableArray2.default)(coordinates[0]), [0, 0, 1], (0, _toConsumableArray2.default)(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);
  var indexs = [0, 1, 2, 3, 4, 5];
  return {
    vertices: positions,
    indices: indexs,
    size: 5
  };
}

function LineArcTriangulation(feature, segmentNumber) {
  var segNum = segmentNumber ? segmentNumber : 30;
  var coordinates = feature.coordinates;
  var positions = [];
  var indexArray = [];

  var _loop = function _loop(i) {
    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);

    if (i !== segNum - 1) {
      indexArray.push.apply(indexArray, (0, _toConsumableArray2.default)([0, 1, 2, 1, 3, 2].map(function (v) {
        return i * 2 + v;
      })));
    }
  };

  for (var i = 0; i < segNum; i++) {
    _loop(i);
  }

  return {
    vertices: positions,
    indices: indexArray,
    size: 7
  };
}

function HeatmapTriangulation(feature) {
  var coordinates = feature.coordinates;

  if (coordinates.length === 2) {
    coordinates.push(0);
  }

  var size = feature.size;
  var dir = addDir(-1, 1);
  var dir1 = addDir(1, 1);
  var dir2 = addDir(-1, -1);
  var dir3 = addDir(1, -1);
  var positions = [].concat((0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir2), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir3), (0, _toConsumableArray2.default)(coordinates), (0, _toConsumableArray2.default)(dir1));
  var indexArray = [0, 1, 2, 3, 0, 2];
  return {
    vertices: positions,
    indices: indexArray,
    size: 5
  };
}

function getGeometry(shape) {
  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (GeometryCache && GeometryCache[shape]) {
    return GeometryCache[shape];
  }

  var path = _Path.geometryShape[shape] ? _Path.geometryShape[shape]() : _Path.geometryShape.cylinder();
  var geometry = (0, _extrude.extrude_PolygonNormal)([path], needFlat);
  GeometryCache[shape] = geometry;
  return geometry;
}

function computeVertexNormals(positions, indexArray) {
  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var normals = new Float32Array(positions.length / dim * 3);
  var vA;
  var vB;
  var vC;

  var cb = _glMatrix.vec3.create();

  var ab = _glMatrix.vec3.create();

  var normal = _glMatrix.vec3.create();

  for (var i = 0, li = indexArray.length; i < li; i += 3) {
    vA = indexArray[i + 0] * 3;
    vB = indexArray[i + 1] * 3;
    vC = indexArray[i + 2] * 3;
    var p1 = [positions[vA], positions[vA + 1]];
    var p2 = [positions[vB], positions[vB + 1]];
    var p3 = [positions[vC], positions[vC + 1]];

    if (needFlat) {
      p1 = (0, _l7Utils.lngLatToMeters)(p1);
      p2 = (0, _l7Utils.lngLatToMeters)(p2);
      p3 = (0, _l7Utils.lngLatToMeters)(p3);
    }

    var _p = p1,
        _p2 = (0, _slicedToArray2.default)(_p, 2),
        ax = _p2[0],
        ay = _p2[1];

    var pA = _glMatrix.vec3.fromValues(ax, ay, positions[vA + 2]);

    var _p3 = p2,
        _p4 = (0, _slicedToArray2.default)(_p3, 2),
        bx = _p4[0],
        by = _p4[1];

    var pB = _glMatrix.vec3.fromValues(bx, by, positions[vB + 2]);

    var _p5 = p3,
        _p6 = (0, _slicedToArray2.default)(_p5, 2),
        cx = _p6[0],
        cy = _p6[1];

    var pC = _glMatrix.vec3.fromValues(cx, cy, positions[vC + 2]);

    _glMatrix.vec3.sub(cb, pC, pB);

    _glMatrix.vec3.sub(ab, pA, pB);

    _glMatrix.vec3.cross(normal, cb, ab);

    normals[vA] += cb[0];
    normals[vA + 1] += cb[1];
    normals[vA + 2] += cb[2];
    normals[vB] += cb[0];
    normals[vB + 1] += cb[1];
    normals[vB + 2] += cb[2];
    normals[vC] += cb[0];
    normals[vC + 1] += cb[1];
    normals[vC + 2] += cb[2];
  }

  normalizeNormals(normals);
  return normals;
}

function normalizeNormals(normals) {
  for (var i = 0, li = normals.length; i < li; i += 3) {
    var normal = _glMatrix.vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);

    var newNormal = _glMatrix.vec3.create();

    _glMatrix.vec3.normalize(newNormal, normal);

    normals.set(newNormal, i);
  }
}

function checkIsClosed(points) {
  var p1 = points[0][0];
  var p2 = points[0][points[0].length - 1];
  return p1[0] === p2[0] && p1[1] === p2[1];
}

function getHeatmapGeometry(shape) {
  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];
  var path = _Path.geometryShape[shape] ? _Path.geometryShape[shape]() : _Path.geometryShape.circle();
  var geometry = shape3d.indexOf(shape) === -1 ? (0, _extrude.fillPolygon)([path]) : (0, _extrude.default)([path]);
  return geometry;
}

function addDir(dirX, dirY) {
  var x = (dirX + 1) / 2;
  var y = (dirY + 1) / 2;
  return [x, y];
}

function earthTriangulation() {
  var earthmesh = (0, _utils.primitiveSphere)(_utils.EARTH_RADIUS, {
    segments: _utils.EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
      indicesArr = earthmesh.indicesArr,
      normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}

function earthOuterTriangulation() {
  var earthmesh = (0, _utils.primitiveSphere)(_utils.EARTH_RADIUS + _utils.EARTH_RADIUS_OUTER, {
    segments: _utils.EARTH_SEGMENTS
  });
  var positionsArr = earthmesh.positionsArr,
      indicesArr = earthmesh.indicesArr,
      normalArr = earthmesh.normalArr;
  return {
    vertices: positionsArr,
    indices: indicesArr,
    size: 5,
    normals: normalArr
  };
}
//# sourceMappingURL=triangulation.js.map